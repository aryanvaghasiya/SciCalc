\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue]{hyperref}
\usepackage{geometry}
\geometry{
    a4paper,
    top=25mm,
    bottom=25mm,
    left=25mm,
    right=25mm,
    headheight=14pt,
    footskip=12pt,
}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{booktabs}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codesilver}{rgb}{0.9,0.9,0.9}
\definecolor{codeblue}{rgb}{0.1,0.1,0.8}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{magenta},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

% Custom commands
\newcommand{\sectionbreak}{\clearpage}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Scientific Calculator with DevOps Pipeline}
\fancyhead[R]{\thepage}
\fancyfoot[C]{IMT2022048}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    \hrule height 1pt
    \vspace{0.5cm}
    {\Huge\bfseries Mini Project Report}\\[0.5cm]
    {\huge\bfseries Scientific Calculator with DevOps Pipeline}\\[0.5cm]
    \hrule height 1pt
    
    \vspace{2cm}
    {\Large\bfseries Student Name: Areen Vaghasiya}\\[0.5cm]
    {\Large\bfseries Roll Number: IMT2022048}\\[0.5cm]
    {\Large\bfseries Project Title: Scientific Calculator with DevOps Pipeline}\\[0.5cm]
    
    \vfill
    {\Large \today}
\end{titlepage}

\clearpage
\tableofcontents
\clearpage

\section{Introduction}
\label{1-introduction}

\subsection{Problem Statement}
This project develops a scientific calculator implementing:
\begin{itemize}
    \item Square root function: $\sqrt{x}$
    \item Factorial function: $x!$
    \item Natural logarithm (base e): $\ln(x)$
    \item Power function: $x^b$
\end{itemize}

\subsection{Project Goal}
The project implements a complete DevOps pipeline demonstrating CI/CD practices, automated testing, containerization, and configuration management.

\section{What and Why of DevOps?}
\label{2-what-and-why-of-devops}

\subsection{What is DevOps?}
DevOps unifies software development (Dev) and IT operations (Ops) to deliver applications faster and more reliably. It emphasizes:

\begin{itemize}
    \item \textbf{Collaboration:} Breaking down barriers between development and operations teams
    \item \textbf{Automation:} Automating repetitive tasks throughout the software lifecycle
    \item \textbf{Continuous Feedback:} Establishing feedback loops for rapid iteration
    \item \textbf{Monitoring:} Continuous observation of application performance
\end{itemize}

Key components include Continuous Integration (CI), Continuous Delivery/Deployment (CD), Infrastructure as Code (IaC), automated testing, and monitoring.

\subsection{Why DevOps?}
DevOps adoption provides:

\begin{enumerate}
    \item \textbf{Faster Release Cycles:} Automation enables rapid deployment
    \item \textbf{Improved Quality:} Automated testing catches bugs early
    \item \textbf{Enhanced Scalability:} Infrastructure as code facilitates scaling
    \item \textbf{Reduced Deployment Risk:} Automated deployments with rollback capabilities
    \item \textbf{Better Collaboration:} Unified tooling improves team communication
    \item \textbf{Cost Efficiency:} Automation reduces manual effort
\end{enumerate}

\subsection{DevOps Lifecycle}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/DevOps-Loop-1200.png}
    \caption{DevOps Lifecycle}
    \label{fig:devops-loop}
\end{figure}

\section{Tools Used}
\label{3-tools-used}

\begin{table}[H]
    \centering
    \caption{Tools Used in the DevOps Pipeline}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Pipeline Stage} & \textbf{Tool} & \textbf{Purpose} \\
        \hline
        Source Control & Git + GitHub & Version control and collaboration \\
        Automated Testing & JUnit 5 & Unit testing framework \\
        Build Management & Maven & Build automation and dependency management \\
        Continuous Integration & Jenkins & CI/CD pipeline orchestration \\
        Webhook Tunneling & ngrok & GitHub-Jenkins webhook connectivity \\
        Containerization & Docker & Application containerization \\
        Container Registry & Docker Hub & Image storage and distribution \\
        Configuration Management & Ansible & Automated deployment \\
        \hline
    \end{tabular}
\end{table}

\section{Pipeline Architecture}
\label{4-pipeline-architecture}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/Devops-flow.png}
    \caption{Pipeline Architecture Overview}
    \label{fig:pipeline-architecture-overview}
\end{figure}

\textbf{Pipeline Workflow:}
\begin{enumerate}
    \item Developer pushes code to GitHub repository
    \item GitHub webhook triggers Jenkins via ngrok tunnel
    \item Jenkins pipeline executes via Jenkinsfile (provides stage view)
    \item Jenkins pulls latest code from GitHub repository
    \item Maven runs automated test cases using JUnit
    \item Docker builds container image from Dockerfile
    \item Jenkins logs into Docker Hub using credentials
    \item Docker image is pushed to Docker Hub registry
    \item Ansible deploys container on local system
    \item Email notification sent about pipeline success/failure
\end{enumerate}

\section{Implementation Details}
\label{5-implementation-details}

\subsection{Source Control Management (Git + GitHub)}
\subsubsection{Setup}
\begin{lstlisting}[language=bash, caption={Git Setup Commands}]
# Initialize local Git repository
git init

# Add remote repository
git remote add origin https://github.com/AV-AKIHIRO/Scientific-Calculator-SPE.git

# Stage and commit files
git add .
git commit -m "Initial commit: Calculator implementation"

# Push to remote
git push -u origin main
\end{lstlisting}

\subsubsection{Repository Structure}
\begin{lstlisting}[language=bash, numbers=none, caption={Project Repository Structure}]
Scientific-Calculator-SPE/
|-- src/
|   |-- main/
|   |   |-- java/
|   |       |-- calculator/
|   |           |-- BasicOps.java
|   |           |-- AdvOps.java
|   |-- test/
|       |-- java/
|           |-- calculator/
|               |-- BasicOpsTest.java
|               |-- AdvOpsTest.java
|-- target/              (Maven build directory)
|   |-- ...
|-- pom.xml
|-- Dockerfile
|-- Jenkinsfile
|-- deploy.yml
|-- inventory.ini
|-- Report.md
|-- README.md
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/github-1.png}
    \caption{Project structure in GitHub repository}
    \label{fig:github-repo-structure}
\end{figure}

\subsubsection{Commit History}
Regular commits were made throughout the project development to maintain a clear history of changes.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/github-commits.png}
    \caption{Commit history showing project progression}
    \label{fig:github-commit-history}
\end{figure}

\subsection{Testing (JUnit 5)}
JUnit 5 provides a robust framework for automated testing of Java applications.

\subsubsection{Configuration}
JUnit 5 dependency in \texttt{pom.xml}:
\begin{lstlisting}[language=xml, caption={JUnit 5 Dependency in \texttt{pom.xml}}]
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.9.2</version>
    <scope>test</scope>
</dependency>
\end{lstlisting}

\subsubsection{Test Classes}
Test classes were created in the \texttt{src/test/java} directory to verify the correctness of all calculator operations including square root, factorial, logarithm, and power functions.

\subsubsection{Test Execution}
\begin{lstlisting}[language=bash, caption={Maven Test Command}]
mvn test
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/mvn-test.png}
    \caption{Successful test execution}
    \label{fig:mvn-test-success}
\end{figure}

\subsection{Build Tool (Maven)}
Apache Maven is a powerful project management and build automation tool based on the Project Object Model (POM). Maven simplifies the build process, manages dependencies, and creates executable artifacts.

\subsubsection{Maven Project Structure}
Maven follows a standard directory layout:

\begin{lstlisting}[numbers=none, caption={Maven Directory Structure}]
project/
|-- src/
|   |-- main/
|   |   |-- java/          (Application source code)
|   |   |-- resources/     (Configuration files)
|   |-- test/
|       |-- java/          (Test source code)
|       |-- resources/     (Test resources)
|-- target/                (Build output directory)
|-- pom.xml                (Project Object Model configuration)
\end{lstlisting}

The \texttt{pom.xml} file defines project metadata, dependencies, plugins, and build configurations.

\subsubsection{Build Process}
\begin{lstlisting}[language=bash, caption={Maven Clean and Package Command}]
mvn clean package
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/mvn-clean-package-1.png}
    \caption{Maven build process - compilation and testing}
    \label{fig:mvn-build-part1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/mvn-clean-package-2 mvn-test.png}
    \caption{Maven build process - packaging and artifact creation}
    \label{fig:mvn-build-part2}
\end{figure}

\subsection{Continuous Integration (Jenkins)}
Jenkins is an open-source automation server that enables continuous integration and continuous delivery. It automates the entire build, test, and deployment pipeline, triggered by code changes.

\subsubsection{Benefits of Jenkins}
\begin{itemize}
    \item \textbf{Automation:} Streamlines repetitive tasks like building, testing, and deploying code
    \item \textbf{Extensibility:} Supports a wide range of plugins to integrate with tools like Git, Maven, and Docker
    \item \textbf{Flexibility:} Configurable pipelines allow customization of CI/CD workflows
    \item \textbf{Scalability:} Supports distributed builds across multiple nodes for faster processing
    \item \textbf{Community Support:} Large open-source community provides extensive resources and plugins
\end{itemize}

\subsubsection{Setup}
\begin{lstlisting}[language=bash, caption={Jenkins Installation Commands}]
# Install Jenkins
wget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -
sudo sh -c 'echo deb https://pkg.jenkins.io/debian-stable binary/ > /etc/apt/sources.list.d/jenkins.list'
sudo apt-get update
sudo apt-get install jenkins

# Start Jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins
\end{lstlisting}

Access Jenkins at \texttt{http://localhost:8080}.

\subsubsection{Install Required Plugins}
Navigate to \textbf{Manage Jenkins \(\rightarrow\) Manage Plugins} and install:
\begin{itemize}
    \item Git Plugin
    \item Maven Integration Plugin
    \item Docker Pipeline Plugin
    \item Ansible Plugin
    \item GitHub Integration Plugin
    \item Email Extension Plugin (for email notifications)
\end{itemize}

\subsubsection{Configure Global Tools}
Navigate to \textbf{Manage Jenkins \(\rightarrow\) Global Tool Configuration} and configure:
\begin{itemize}
    \item \textbf{JDK:} Specify Java installation path (JDK 17)
    \item \textbf{Maven:} Add Maven installation (name: \texttt{Maven\_3.9.9}, version: 3.9.9)
    \item \textbf{Git:} Verify Git executable path
    \item \textbf{Docker:} Configure Docker installation
    \item \textbf{Ansible:} Specify Ansible executable path
\end{itemize}

\subsubsection{Configure Email Notifications}
Navigate to \textbf{Manage Jenkins \(\rightarrow\) Configure System} and configure Extended E-mail Notification:
\begin{itemize}
    \item \textbf{SMTP Server:} smtp.gmail.com (for Gmail)
    \item \textbf{SMTP Port:} 587
    \item \textbf{Use SSL:} Unchecked
    \item \textbf{Use TLS:} Checked
    \item \textbf{Credentials:} Add Gmail credentials (email and app password)
    \item \textbf{Default Recipients:} areen.vaghasiya+jenkins@iiitb.ac.in
\end{itemize}

\textbf{Note:} For Gmail, you need to generate an App Password from Google Account settings if 2-factor authentication is enabled.

\subsubsection{Configure Credentials}
Navigate to \textbf{Manage Jenkins \(\rightarrow\) Manage Credentials} and add:
\begin{itemize}
    \item GitHub credentials (username/password or personal access token)
    \item Docker Hub credentials (username/password with ID: \texttt{dockerhub-credentials})
\end{itemize}

\subsubsection{Jenkins URL Configuration}
Navigate to \textbf{Manage Jenkins \(\rightarrow\) Configure System} and set:
\begin{itemize}
    \item \textbf{Jenkins URL:} \texttt{https://clayton-pursuable-felecia.ngrok-free.dev/}
\end{itemize}

This ngrok URL enables GitHub to communicate with the locally hosted Jenkins instance through a secure tunnel.

\subsubsection{GitHub Webhook Configuration}
\textbf{Setting up ngrok Tunnel:}

Since Jenkins is running locally, ngrok creates a secure tunnel to expose the local Jenkins instance to the internet, allowing GitHub to send webhook notifications.

\begin{lstlisting}[language=bash, caption={Starting ngrok Tunnel}]
# Start ngrok tunnel on port 8080 (Jenkins default port)
ngrok http 8080
\end{lstlisting}

\textbf{Configuring GitHub Webhook:}

\begin{enumerate}
    \item Navigate to your GitHub repository: \texttt{SciCalc}
    \item Go to \textbf{Settings \(\rightarrow\) Webhooks \(\rightarrow\) Add webhook}
    \item Configure the webhook:
    \begin{itemize}
        \item \textbf{Payload URL:} \texttt{https://clayton-pursuable-felecia.ngrok-free.dev/github-webhook/}
        \item \textbf{Content type:} \texttt{application/json}
        \item \textbf{Which events:} Select ``Just the push event''
        \item \textbf{Active:} Check this option
    \end{itemize}
    \item Click \textbf{Add webhook}
\end{enumerate}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/ngrok_webhook.png}
    \caption{Ngrok static URL for this project}
    \label{fig:ngrok-static-url}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/webhook.png}
    \caption{Webhook setup in Github repo settings}
    \label{fig:github-webook}
\end{figure}
\textbf{How It Works:}
\begin{enumerate}
    \item Developer pushes code to GitHub repository
    \item GitHub sends POST request to the ngrok webhook URL
    \item ngrok tunnels the request to local Jenkins instance (port 8080)
    \item Jenkins receives webhook notification and triggers the pipeline defined in Jenkinsfile
    \item Pipeline stages are displayed in Jenkins Stage View UI
    \item Pipeline executes following stages sequentially:
    \begin{itemize}
        \item \textbf{Checkout:} Pulls latest code from GitHub
        \item \textbf{Build:} Compiles source code using Maven
        \item \textbf{Test:} Runs JUnit test cases
        \item \textbf{Package:} Creates JAR artifact
        \item \textbf{Build Docker Image:} Builds container image
        \item \textbf{Push to Docker Hub:} Logs in and pushes image
        \item \textbf{Deploy with Ansible:} Deploys on local system
    \end{itemize}
    \item Post-build action sends email notification about success or failure
\end{enumerate}

\textbf{Important Notes:}
\begin{itemize}
    \item The ngrok URL changes with each session unless using a paid plan with reserved domains
    \item Ensure ngrok is running whenever automated builds are required
    \item Update GitHub webhook URL if ngrok URL changes
    \item For production environments, Jenkins should be hosted on a public server with a static URL
\end{itemize}

\subsubsection{Create Jenkins Pipeline Job}
\begin{enumerate}
    \item Click \textbf{New Item} in Jenkins dashboard
    \item Enter job name: \texttt{Scientific-Calculator-Pipeline}
    \item Select \textbf{Pipeline} and click \textbf{OK}
    \item In job configuration:
    \begin{itemize}
        \item Check \textbf{GitHub project} and enter repository URL
        \item Under \textbf{Build Triggers}, check \textbf{GitHub hook trigger for GITScm polling}
        \item Under \textbf{Pipeline}, select \textbf{Pipeline script from SCM}
        \item Select \textbf{Git} as SCM
        \item Enter repository URL and credentials
        \item Specify branch: \texttt{*/main}
        \item Script Path: \texttt{Jenkinsfile}
    \end{itemize}
    \item Click \textbf{Save}
\end{enumerate}

\subsubsection{Jenkinsfile}
\begin{lstlisting}[language=groovy, caption={Jenkins Pipeline Script (\texttt{Jenkinsfile})}]
pipeline {
    agent any  

    tools {
        maven 'Maven_3.6.3'   // Must match Global Tool Config name in Jenkins
        jdk 'JDK17'
    }

    environment {
        DOCKER_IMAGE = "aryanvaghasiya/scicalc-app"
        inventory file (e.g., hosts.ini)
        ANSIBLE_INVENTORY = "hosts.ini" 
        ANSIBLE_PLAYBOOK = "deploy.yml"
    }

    stages {
        stage('Checkout') {
            steps {
                // Pull code from GitHub
                git branch: 'main', url: 'https://github.com/aryanvaghasiya/SciCalc'
            }
        }

        stage('Build') {
            steps {
                // clean and compile
                sh 'mvn clean compile'
            }
        }

        stage('Test') {
            steps {
                // run unit tests
                sh 'mvn test'
            }
        }

        stage('Package') {
            steps {
                // create the jar file
                sh 'mvn package'
            }
        }
        
        stage('Archive Artifact') {
            steps {
                // Save JAR file inside Jenkins
                archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
            }
        }

        stage('Docker Build & Push') {
            steps {
                script {
                    docker.withRegistry('https://index.docker.io/v1/', 'dockerhub-credentials') {
                        // Build Docker image with version tag
                        def app = docker.build("${DOCKER_IMAGE}:${env.BUILD_NUMBER}")
                        // Push with build number tag
                        app.push()
                        // Also push as latest
                        app.push("latest")
                    }
                }
            }
        }
        
        stage('Ansible Deploy') {
            steps {
                echo "Starting Ansible deployment for image ${DOCKER_IMAGE}:${env.BUILD_NUMBER}"
                
                // Execute the playbook.
                sh "ansible-playbook -i ${ANSIBLE_INVENTORY} ${ANSIBLE_PLAYBOOK} -e \"docker_image_tag=${DOCKER_IMAGE}:${env.BUILD_NUMBER}\""
            }
        }
    }

    post {
        success {
            echo "Build #${env.BUILD_NUMBER} completed successfully!"
            emailext(
                to: 'aryan.vaghasiya@iiitb.ac.in',
                subject: "Jenkins Build SUCCESS: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """
                Hi Team,

                The Jenkins pipeline for *${env.JOB_NAME}* completed successfully.
                Docker Image pushed: ${DOCKER_IMAGE}:${env.BUILD_NUMBER}
                Deployment initiated via Ansible.

                Regards,
                Jenkins CI/CD(Aryan Vaghasiya)
                """
            )
        }
        failure {
            echo "Build #${env.BUILD_NUMBER} failed!"
            emailext(
                to: 'aryan.vaghasiya@iiitb.ac.in',
                subject: "Jenkins Build FAILURE: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                body: """
                Hi Team,

                The Jenkins pipeline for *${env.JOB_NAME}* has FAILED.
                Please check Jenkins logs for details.

                Regards,
                Jenkins CI/CD(Aryan Vaghasiya)
                """
            )
        }
    }
}

\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/Pipeline.png}
    \caption{Jenkins pipeline execution showing all stages in Stage View}
    \label{fig:jenkins-pipeline-run}
\end{figure}

\textbf{Jenkins Stage View:} The Jenkinsfile creates a visual representation of the pipeline stages in Jenkins UI, allowing developers to monitor the progress of each stage and quickly identify any failures. Each stage is color-coded (green for success, red for failure) and displays execution time.

\subsection{Containerization (Docker)}
Docker is a platform for developing, shipping, and running applications in containers. Containers package an application with all its dependencies, ensuring consistent behavior across different environments.

\subsubsection{Benefits of Containerization}
\begin{itemize}
    \item \textbf{Portability:} Run anywhere Docker is installed
    \item \textbf{Isolation:} Applications run in isolated environments
    \item \textbf{Efficiency:} Lightweight compared to virtual machines
    \item \textbf{Scalability:} Easy to scale horizontally
    \item \textbf{Version Control:} Images are versioned and reproducible
    \item \textbf{Consistency:} Eliminates ``works on my machine'' problems
\end{itemize}

\subsubsection{Dockerfile}
\begin{lstlisting}[language=docker, caption={Dockerfile for Scientific Calculator}]
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/scientific-calculator-1.0-SNAPSHOT.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
\end{lstlisting}

\textbf{Dockerfile Explanation:}
\begin{itemize}
    \item \texttt{FROM openjdk:17-jdk-slim}: Uses lightweight OpenJDK 17 base image
    \item \texttt{WORKDIR /app}: Sets working directory inside container
    \item \texttt{COPY}: Copies JAR file from Maven target directory
    \item \texttt{ENTRYPOINT}: Defines command to run the application
\end{itemize}

\subsubsection{Build and Run Locally}
\begin{lstlisting}[language=bash, caption={Docker Build and Run Commands}]
# Build image
docker build -t areen9295/calc-app2:latest .

# Run container interactively
docker run -it --rm areen9295/calc-app2:latest

# Run container in detached mode
docker run -d --name calc-container areen9295/calc-app2:latest
\end{lstlisting}

\subsection{Docker Hub Repository}
Docker Hub serves as the central registry for storing and distributing Docker images.

\subsubsection{Manual Push to Docker Hub}
\begin{lstlisting}[language=bash, caption={Docker Login and Push Commands}]
# Login to Docker Hub
docker login

# Push image
docker push areen9295/calc-app2:latest
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/dockerhub-repository.png}
    \caption{Docker Hub repository showing multiple image versions}
    \label{fig:dockerhub-repository}
\end{figure}

\textbf{Repository Link:} \url{https://hub.docker.com/r/areen9295/calc-app2}

\subsection{Continuous Deployment (Ansible)}
Ansible is an open-source automation tool for configuration management, application deployment, and task automation. It uses YAML-based playbooks and operates in an agentless manner using SSH.

\subsubsection{Installation}
\begin{lstlisting}[language=bash, caption={Ansible Installation and Verification}]
# Install Ansible
sudo apt update
sudo apt install ansible -y

# Verify installation
ansible --version
\end{lstlisting}

\subsubsection{Ansible Project Structure}
\begin{lstlisting}[language=bash, caption={Ansible Project Structure}]
Scientific-Calculator-SPE/
|-- ...other files...
|-- inventory.ini      (Ansible inventory file)
|-- deploy.yml         (Ansible playbook)
\end{lstlisting}

\subsubsection{Inventory File}
\begin{lstlisting}[language=ini, caption={Ansible Inventory File (\texttt{inventory.ini})}]
[local]
localhost ansible_connection=local
\end{lstlisting}

\textbf{Explanation:}
\begin{itemize}
    \item \texttt{[local]}: Defines a host group named ``local''
    \item \texttt{localhost}: Target host for deployment
    \item \texttt{ansible\_connection=local}: Uses local connection instead of SSH
\end{itemize}

\subsubsection{Deployment Playbook}
\begin{lstlisting}[language=yaml, caption={Ansible Deployment Playbook (\texttt{deploy.yml})}]
---
- name: Deploy Scientific Calculator Docker container
  hosts: local
  become: no
  tasks:
    - name: Ensure Python 'docker' package is installed
      ansible.builtin.pip:
        name: docker
        state: present

    - name: Deploy and manage SciCalc container from Docker Hub
      community.docker.docker_container:
        name: calc-app2
        image: areen9295/calc-app2:latest
        state: started
        pull: yes
        recreate: yes
        ports:
          - "9000:80"
        restart_policy: always
\end{lstlisting}

\textbf{Playbook Explanation:}
\begin{itemize}
    \item \textbf{Ensure Python 'docker' package:} Installs Python Docker library required by Ansible Docker modules
    \item \textbf{Deploy container:} Pulls latest image from Docker Hub, recreates container if exists, maps port 9000 on host to port 80 in container
    \item \textbf{Restart policy:} Ensures container automatically restarts on failure
\end{itemize}

\subsubsection{Execution}
\begin{lstlisting}[language=bash, caption={Ansible Playbook Execution}]
# Deploy application
ansible-playbook -i inventory.ini deploy.yml

# Deploy with specific image tag
ansible-playbook -i inventory.ini deploy.yml -e docker_image_tag=latest
\end{lstlisting}

\subsubsection{Ansible Deployment Output}
When executed successfully, Ansible displays:
\begin{itemize}
    \item PLAY: Shows which playbook is being executed
    \item TASK: Lists each task being performed
    \item PLAY RECAP: Summary of successful, failed, and changed tasks
\end{itemize}

\section{Application Output}
\label{6-application-output}

The scientific calculator application runs inside a Docker container and provides an interactive command-line interface. Users can perform the following operations:

\begin{itemize}
    \item Square root calculation: $\sqrt{x}$
    \item Factorial calculation: $x!$
    \item Natural logarithm: $\ln(x)$
    \item Power calculation: $x^b$
\end{itemize}

The application validates input values and handles edge cases such as negative inputs for square root and logarithm operations, ensuring robust functionality.

\section{Challenges and Solutions}
\label{7-challenges-and-solutions}

\subsection{Challenge 1: Docker Permission Issues}
\textbf{Problem:} When running Docker commands from Jenkins, permission denied errors occurred because the Jenkins user lacked permissions to interact with the Docker daemon.

\textbf{Solution:} Added Jenkins user to Docker group and restarted Jenkins service.
\begin{lstlisting}[language=bash, caption={Fixing Docker Permissions for Jenkins}]
# Add Jenkins user to Docker group
sudo usermod -aG docker jenkins

# Restart Jenkins to apply changes
sudo systemctl restart jenkins

# Verify group membership
groups jenkins
\end{lstlisting}

\subsection{Challenge 2: Ansible SSH Connection}
\textbf{Problem:} Ansible failed to connect to localhost via SSH due to missing SSH key authentication, causing manual password prompts that broke automation.

\textbf{Solution:} Configured SSH key-based authentication for localhost.
\begin{lstlisting}[language=bash, caption={Setting up SSH Key Authentication}]
# Generate SSH key pair (if not exists)
ssh-keygen -t rsa -b 4096

# Copy public key to authorized_keys
ssh-copy-id localhost

# Test SSH connection
ssh localhost
\end{lstlisting}

Alternatively, used \texttt{ansible\_connection=local} in inventory file to bypass SSH entirely for localhost deployments.

\subsection{Challenge 3: Maven Dependency Resolution}
\textbf{Problem:} Maven build failures occurred due to corrupted local repository cache or network issues preventing dependency downloads.

\textbf{Solution:} Forced Maven to update dependencies and cleaned local repository.
\begin{lstlisting}[language=bash, caption={Forcing Maven Dependency Update}]
# Force update all dependencies
mvn clean install -U

# Clear local repository cache if needed
rm -rf ~/.m2/repository
mvn clean install
\end{lstlisting}

\subsection{Challenge 4: ngrok URL Changes}
\textbf{Problem:} The free tier of ngrok generates a new URL each time the tunnel is restarted, requiring manual updates to GitHub webhook and Jenkins URL configuration.

\textbf{Solution:} 
\begin{itemize}
    \item Documented the process for updating webhook URL in GitHub
    \item Considered upgrading to ngrok paid plan for static domain (for production use)
    \item For production deployment, hosted Jenkins on a cloud platform with static public IP
\end{itemize}

\subsection{Challenge 5: JUnit Test Failures}
\textbf{Problem:} Initial test cases failed due to floating-point precision issues in calculator operations.

\textbf{Solution:} Modified test assertions to use delta comparison for floating-point values.
\begin{lstlisting}[language=java, caption={JUnit Assertion with Delta}]
// Instead of exact equality
assertEquals(expected, actual);

// Use delta for floating-point comparison
assertEquals(expected, actual, 0.0001);
\end{lstlisting}

\section{Conclusion}
\label{8-conclusion}

\subsection{Project Summary}
This project successfully implemented a scientific calculator application with a complete end-to-end DevOps pipeline. The pipeline automates the entire software delivery process from code commit to deployment:

\begin{enumerate}
    \item \textbf{Code Push:} Developer pushes code to GitHub
    \item \textbf{Webhook Trigger:} GitHub webhook automatically notifies Jenkins via ngrok
    \item \textbf{Pipeline Execution:} Jenkinsfile orchestrates the entire pipeline with visual stage view
    \item \textbf{Code Checkout:} Jenkins pulls latest code from GitHub repository
    \item \textbf{Automated Testing:} JUnit test cases validate code functionality
    \item \textbf{Image Building:} Docker creates containerized application image
    \item \textbf{Registry Push:} Image is pushed to Docker Hub after successful authentication
    \item \textbf{Deployment:} Ansible automates deployment on local system
    \item \textbf{Notification:} Email alerts inform about pipeline success or failure
\end{enumerate}

This implementation demonstrates industry-standard DevOps practices including source control, automated testing, containerization, and infrastructure as code.

\subsection{Learning Outcomes}
Key learnings from this project include:
\begin{itemize}
    \item \textbf{Infrastructure as Code:} Implementing automated deployments using Ansible playbooks
    \item \textbf{Pipeline as Code:} Defining CI/CD workflows declaratively using Jenkinsfile
    \subsection{Benefits Achieved}
\begin{itemize}
    \item \textbf{Automation:} Complete automation from code commit to deployment
    \item \textbf{Quality Assurance:} Automated testing ensures code reliability
    \item \textbf{Faster Deployment:} Reduced deployment time through automation
    \item \textbf{Consistency:} Containerization ensures consistent behavior across environments
    \item \textbf{Reproducibility:} All builds and deployments are reproducible
    \item \textbf{Visibility:} Stage view and email notifications provide clear pipeline status
    \item \textbf{Reliability:} Automated rollback capabilities reduce deployment risks
\end{itemize}

\subsection{Future Enhancements}
Potential improvements for the project:
\begin{itemize}
    \item Deploy Jenkins on cloud platform with static public IP
    \item Implement Docker Compose for multi-container deployments
    \item Add integration tests alongside unit tests
    \item Implement blue-green deployment strategy
    \item Add monitoring and logging with ELK stack or Prometheus
    \item Implement automated security scanning for Docker images
    \item Add load balancing for horizontal scaling
\end{itemize}

\section{References}
\label{9-references}

\begin{enumerate}[label=\arabic*.]
    \item \textbf{Git:} \url{https://git-scm.com/doc}
    \item \textbf{JUnit 5:} \url{https://junit.org/junit5/docs/current/user-guide/}
    \item \textbf{Maven:} \url{https://maven.apache.org/guides/}
    \item \textbf{Jenkins:} \url{https://www.jenkins.io/doc/}
    \item \textbf{Docker:} \url{https://docs.docker.com}
    \item \textbf{Docker Hub:} \url{https://docs.docker.com/docker-hub/}
    \item \textbf{Ansible:} \url{https://docs.ansible.com}
    \item \textbf{ngrok:} \url{https://ngrok.com/docs}
    \item \textbf{DevOps Overview:} \url{https://aws.amazon.com/devops/what-is-devops/}
    \item \textbf{GitHub Webhooks:} \url{https://docs.github.com/en/webhooks}
\end{enumerate}

\end{document}
